#### I have learnt many productive thing on week and I'm eager to learn many more. I learned about three problem and hoe to solve that. The first one was Two Sum, where I had to find two numbers in an array that add up to a given target. These numbers should not be repeated. For example, if the target is 6 and the array has only one 3, I cannot use the same number twice. I solved this using a nested loop, checking each pair of numbers to see if their sum matched the target. If it did, I returned their indices. The second problem was Valid Palindrome.  palindrome is a word or phrase that reads the same forward and backward after converting all uppercase letters to lowercase and removing non-alphanumeric characters like punctuation and spaces. 
#### I learned about Alpha numeric expressions, which helped me clean the string by removing unwanted characters. Then, I checked if the cleaned string was the same when reversed. If it was, the function returned true; otherwise, it returned false. The third problem was First Unique Character in a String, where I had to find the first non-repeating character and return its index. If no unique character was found, I had to return -1. To solve this, I used an object to count how many times each character appeared in the string. Then, I went through the string again to find the first character that appeared only once. I worked on an Angular weather widget that displays the current temperature using services. 
### service:
#### I learned that services are used to handle data fetching, logic, and shared functionalities across different components. They help keep the code organized and reusable. Instead of fetching data directly in components, we use services, making the code cleaner and more manageable.
### Dependency Injection: 
#### I also learned about dependency injection, a core feature of Angular. It allows us to create a single instance of a service and use it throughout the application, rather than manually creating new instances. This helps in better resource management and keeps the application efficient. In Angular, we inject the service into a component’s constructor, and Angular automatically provides an instance of the service when needed.
### Class:
#### Then learned about classes. He compared a class to a blueprint, like the design of a house that defines its structure. In programming, a class defines properties (attributes) and methods (functions). For example, in a Car class, properties could be brand, model, and year, while methods define what the car can do, like displaying its details.I also learned that a class can be broken down into two main parts: "has something" (attributes like brand and model) and "does something" (functions like displaying the details). This session gave me a much clearer understanding of how classes work in programming.
### HTTP Client Service:
#### The HTTP Client Service is used to make HTTP requests to APIs. When we request data, the service sends an HTTP request to the API, and in response, it returns data, usually in JSON format. The API URL is important because it tells the server where to send the request.
### HTTP Endpoints: Different types of HTTP requests are used for different actions.
1. GET – Fetches data from the server. We can get all records or a specific record using an ID.
2. POST – Creates a new record in the server. The data is sent in JSON format.
3. PUT – Updates an entire existing record in the server. The request body contains all the updated data.
4. PATCH – Updates only specific fields in an existing record.
5. DELETE – Removes a record from the server.
### Request Body & Headers:
#### When creating or updating data, we send a request body containing the necessary details. Headers help define additional information, such as content type or authentication tokens. The GET request doesn’t have a body since it only retrieves data.
### Importing HttpClient:
#### To use the HTTP Client in Angular, we need to import it. However, I noticed that HttpClientModule appeared as deprecated. I found that the correct way is to import provideHttpClient from @angular/common/http and configure it in app.config.ts. At first, I faced some issues with this, but after checking the official Angular documentation, I was able to configure it correctly.
### Observables:
#### I also learned about Observables, which help handle asynchronous data in JavaScript. Since JavaScript is single-threaded, it executes code line by line. When making an API request, it takes some time to get a response. Observables allow the request to run in the background without blocking other operations. Instead of waiting for the whole response at once, data can be sent in small chunks over time, which improves performance. This process is called streaming. Observables come from the RxJS (Reactive Extensions for JavaScript) library, which provides tools for managing asynchronous data, API calls, user inputs, and real-time events. An Observable follows a pattern where it emits data, and an Observer listens to it by subscribing. The Observer handles three types of events:
1.next() – Emits the next value.
2.error() – Handles errors.
3.complete() – Signals when the stream ends.
### Pipes:
#### Pipes help handle asynchronous data by applying operators to modify data streams. The async pipe is particularly useful because it automatically subscribes to an Observable and unsubscribes when the component is destroyed. This means we don’t need to manually subscribe and unsubscribe. To use Observables properly, we need to install RxJS, import it into the application, and use methods like map() to process the incoming data stream. This way, we can efficiently manage API responses and real-time updates.
#### While learning about HTTP requests in Angular, I understood why Observables are preferred over Promises. The key difference is that Promises return a single value and resolve immediately once they receive the first chunk of data. They return data even if no code is actively using it. However, Observables work differently—they continuously fetch data in a stream and only return values when some code is actively using them. This makes Observables more suitable for handling real-time or large data streams efficiently.
### Angular Directives:
#### ngFor helps iterate over a list or an array, creating an HTML element for each item. This reduces code repetition and makes it easier to display dynamic lists. Instead of writing separate code for each item, *ngFor automates the process, improving efficiency.
#### ngIf is used to conditionally display elements. If the condition is true, the element appears; if false, it is completely removed from the DOM (not just hidden). This improves performance by freeing up memory when elements are not needed. It can also be used with else to show alternative content when the condition is false.
#### Since these are structural directives, we use * as a shorthand instead of writing them inside an <ng-template>. While working on a task, anna suggested using @for and @if. I tried implementing them, but they didn’t work. I thought it might be a version issue, so I updated Angular. Even after updating, I still couldn't use them. Then, Ashini akka advised me to check whether the CommonModule was imported in the component. I verified it, but the issue persisted. Next, I updated Node.js, but I faced installation issues. I searched on Google and learned how to fix them. After installation, I checked if Node.js was installed properly by looking for node.exe. When I found that the path wasn’t set, I fixed it and successfully updated Node.js. However, @for and @if still didn’t work, so Priya akka suggested using ng directives instead.
### Fetching Specific Data from an API:
#### I also learned how to fetch only a specific portion of data from an API instead of retrieving everything. This can be done using:
1.	slice() – Creates a shallow copy of a portion of an array without modifying the original. It takes start and end indexes (e.g., slice(0, 10) retrieves only the first 10 items).
2. filter() – Filters data based on a condition, returning only the required values.
### Functions, classes, and loops:
#### Functions have a name, parameters, a body, and a return type. They return a value or void if there’s no return. Classes contain properties and methods. A simple way to think of them: A class "has something" and "does something. if, else, and else if statements help in decision-making by executing different blocks of code based on conditions. for loops are used to run a block of code multiple times until a condition is met. They help avoid writing repetitive code. Arrays store a list of items and use index values (starting from 0). Objects store data in key-value pairs. Arrays can be considered a type of object because they have indexes as keys and values as list items.
### HTTP post:
#### I learned how to create a new record in the database using the HTTP POST method in Angular. When making a POST request, we need to include HTTP headers, which are key-value pairs sent along with the request. These headers contain important information like authentication details and content type. The Content-Type header tells the server what format the data is being sent in so it can process it correctly. In Angular, we use the JSON pipe to convert an object into a JSON-formatted string so that it can be displayed in the template. To send a POST request, we create a function that holds the data, wrap it in an observable, and send it along with the API URL and necessary headers. The response is handled using the pipe() method, and we display the data using ngIf and the async pipe. The async pipe makes it easier because it automatically subscribes and unsubscribes to the observable, preventing memory leaks.
### Lists, Arrays, and Objects:
#### I also had a session about lists, arrays, and objects. Data types are divided into primitive (like integers, strings, and booleans) and complex (like arrays, objects, and maps). Arrays store ordered data that can be accessed using index values. Objects store data in key-value pairs, where keys must be unique. One key concept I learned was how variables store values. For example: let a = 10; let b = a; Here, b gets a copy of a's value. If we later change a = 20, b will still be 10 because it holds a copy, not a reference. But with arrays, assigning one list to another copies the reference instead of the values. let list1 = [9, 8, 7, 6]; let list2 = list1; If we modify list1, it also affects list2 because both refer to the same memory location. To create a separate copy, we use the spread operator ([...]), which creates a new array with a new memory address. Pass by value means a copy of the data is passed to a function. Pass by reference means the memory address is passed, so changes affect the original data.
### Updating and Deleting Data:
#### I also learned how to update records using the PUT method. When updating data, Create a function with a unique ID to identify the record. Store the updated data in a variable. Return the HTTP PUT request along with the API URL and headers. Similarly, I learned how to delete a record using the DELETE method. The process is almost the same, Create a function, pass the id of the record to be deleted, and return the API call. Call the function from the component and subscribe to it using pipe() and map() to handle the response. I started my day by revisiting HTTP requests and methods. My task was to update and delete a record from an API. When I checked the console, the output was correct, but the changes were not reflecting on the localhost. My mentor suggested calling the get() method after updating the data, but it still didn’t work. After researching, I found that the issue was with the server. The API I was using was a fake JSON API, meant for practice. It only simulates GET and PUT requests but does not actually update or delete records on the frontend.
### Functions and Inner Functions:
#### Later, I attended a session on functions and inner functions. Functions are blocks of code that execute only when called. They have a name, body, and return type. An inner function is a function inside another function. The inner function can access variables from the outer function, but the outer function cannot access variables from the inner function. This helps in keeping certain variables private within a function, preventing them from being accessed from outside.
### Shadowing:
#### I learned about shadowing, which occurs when a local variable has the same name as a global variable. In such cases, the local variable temporarily hides the global variable within its scope. This means that inside the function where the local variable exists, the global variable cannot be accessed. However, once the function execution is over, the global variable remains unchanged.
### Angular Forms:
#### I also learned about forms in Angular, which are used for collecting and validating user input, such as in registration and login pages. Angular provides two types of forms:
1. Reactive Forms – These use TypeScript for handling form logic. They rely on a structured approach where each form field is represented by a special object that tracks user input and validation.
2. Template-Driven Forms – These are simpler and use HTML directives to manage form data. They are useful for small forms where minimal logic is required.
### Setting Up Forms in Angular:
#### Reactive Forms require defining the form inside the component class. Each input field is linked to an object that keeps track of the user’s input and validation. This method is useful for complex forms that need custom validation. Template-Driven Forms use Angular’s built-in directives to bind form elements. These forms rely on Angular’s automatic tracking of user input and are easier to set up for simple use cases like login forms. Both types of forms share common classes that help in managing input fields, groups of fields, dynamic form elements, and even custom components as form controls.
#### After learning these concepts, we had a test on functions. While the explanations seemed clear, solving problems was challenging. I realized that practicing more is the key to improving. Our mentor, Koushick Anna, gave us similar problems as assignments. At home, I revised how global and local variables work inside functions, which made it easier to solve the given problems. Later, we had a session with Askin Anna, who shared his experiences. He encouraged us to take responsibility for our goals and work towards them with dedication.
#### Thank You.








