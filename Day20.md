### Day 20.
#### I started the day with recalling about the HTTP request and their methods. I have given a task to update a record and delete a record from an API. while console I get the output but it is not rendering in the local host. I asked my mentor He asked to call the get() after the updating it. Even after I could not able to see it. Then It was the fault in the server side. Then researched about that API. It is an fake JSON API that are used for practicing. It will only print the get and put function it will not render the update or delete in the local host. Then went to the second floor to attend the session. 
#### I learned about functions, inner functions and how the variables are accessed inside that. Function are a block of code that run when we call it. function has a name. function body {}, and a return type. The function will run only if it is called.  An inner function is a function that is defined inside another function. Inner functions can access variables from their outer function. For example we have a function called outer(x), which takes a number x as an argument. Inside outer, there is another function called inner(y), which takes another number y. The inner function adds x and y together and returns the result. Since inner(y) is defined inside outer(x), it can access x even though x is declared in outer(x). When we call outer(10), x becomes 10. Inside outer, we immediately call inner(5), passing 5 as y. The inner function then adds 10 + 5 = 15 and returns it. As a result, outer(10) also returns 15, and console.log(outer(10)) prints 15 to the console.  Inner functions can access variables from their parent function, but the parent function cannot access variables from the inner function.
#### Then I get to know about shadowing. It occurs when a local variable has the same name as the global variable. By this time, local variable hides the global variable within its scope. Local variable  is a variable that is declared inside a function or block and can only be used within that function. It cannot be accessed outside the function where it is declared. A global variable is a variable that is declared outside any function, making it accessible throughout the entire program. Example for shadowing, we have a global variable score set to 100. Inside the function updateScore(), we declare a local variable with the same name, score, and assign it the value 50. This local variable shadows the global variable, meaning that inside updateScore(), the function only recognizes the local score (which is 50). When print("Inside updateScore: $score") is executed, it prints 50 because the function is referring to the local score. However, when main() calls updateScore(), it does not modify the global score since the local score inside updateScore() only exists within that function. After updateScore() finishes, the program moves to print("Outside updateScore: $score") in main(). Here, score refers to the global variable (which remains 100), so the output prints 100.
#### Then I started to learn about forms in angular. Forms are used to collect and validate user input. For example register, login page, submission and so on. Both reactive and template - driven keeps track and synchronise the user's input value with the components form data. From are of two types.
1. Reactive form
2. Template - driven forms.
#### Reactive forms uses typescript code for form logics. It uses form control and from group. Whereas template - driven uses HTMl directive as template. uses ngForm nd ngModel to track the forms and elements state. It uses ngModel for two - way data binding. It works like this, When a user type input to a form input(textbox), the corresponding data in the component (the form model) is automatically updated. If the form model is updated programatically in the component, then the input field reflects the change.  
#### How to set up in relative forms- we define the form model directly in the component class. The formControl directive is used in the template to link an input field to a FormControl instance that is defined in the component class. This binding allows to internally handle data synchronization between the form field and the form control. A FormControl instance refers to an object created using the FormControl class. each input field is represented by it. It Keeps track of what the user has typed. To use the Relative form in angular we need to import the below.
```js
import{ FormControl, ReactiveFormsModule} from '@angular/forms';
```
#### Now lets see how to set up in Template - driven form. It uses ngModel directive to manage form controls. Template - driven forms are very easy to create and best for simple forms where we do not provide more logic codes. To use the Relative form in angular we need to import the below.
```js
import { FormsModule } from '@angular/forms';
```
#### Common form foundation claases - both Reactive Forms and Template-driven Forms share underlying classes
1. Form control
2. Form group
3. Form array
4. Control value accessor.
#### A FormControl manages the value and validation state of a single input field. A FormGroup is used to manage multiple related form controls as a single unit. A FormArray is an array-like structure that holds multiple FormControl or FormGroup instances dynamically. A Control Value Accessor (CVA) is a way to connect a custom component to Angular forms. It allows Angular to treat a custom component like a normal form control like (input, select). 
#### Then we had a test on the functions. While listening to it made understand how it is. But while solving the problem it was really confusing. I understand that I should work more on problem like this. Also koushick anns gave that problems as assignment. I came home and first understood about how the global and local variables are accessed inside the function. No it was slight easier for me to solve the problem. Then had a session with askin anna. He shared his experience with us. Also told us to be responsible for what you wanted to do and Set a goal and work to achieve that goal.
#### Today was a really good learning day. I understood how APIs work, especially how GET, PUT, and DELETE requests behave. Learning about functions, inner functions, and shadowing made me see how variables work in different parts of a program. I also got a clear idea of how Angular forms work, both reactive and template-driven. The test on functions was a bit challenging, but it showed me where I need more practice. Talking to Askin Anna was inspiring, he reminded us to stay focused and work hard toward our goals. I feel motivated to keep practicing and improving my coding skills.






