### Day 38.
#### Today I learned about controllers. Controllers are responsible for incoming request and sending response to the client. The routing mechanism tells which controller will handle each request. It is very important concept use to organize code. It is a file that handles the logic for a routes. For example an application that has n number of routes and middleware and files etc.. If  its logics and code are written in the single block of code it will be difficult for us to read and understand the program. To overcome this we use controllers. Controller is a file that contains functions for handling the request and sending responses.
#### By using controllers it is easier to manage and access. Readability, it will be helpful for the developers to read, understand the code and work with it. We can reuse the logic for different routes. We can able to keep the logic separate and the routing separate so, it looks cleans. If we didn’t use controllers we will mix up the logics and routing that will become a mess and very hard to read and understand the code. Then I practice it with the todo and user application I did it the day before. 
#### First I created a file named route.js which will be like the director, it listens for the request like /signup, /login, /todos and etc. and it routes them to the correct logic. Then created two separate files which contains the logic for the above requests. One controller file is for users like signup and login, and the other controller file is for todos like get, post, delete. These controllers are the main function that does the actual work. Then created a separate folder as utils and inside that folder we have a file named file.js, it contains the functions like readData() and writeData(). Those functions handle reading from and writing to JSON file. Instead of repeating read and write logic in every controller we can just simply import the utility functions whenever we need them. For storing and getting the details for user and todos controller we use the file.js. We can export those functions from file.js and use import them where ever needed. 
#### Similarly, In each controller we use export to make those function available and import them and connect them the correct routes. Then in the main file we import the route.js and connect it with app.use( ‘ / ‘, routes ), which means all the routes will begin with ‘ / ‘. Everything works together by exporting the controller functions and importing them where needed to keep our code organized. Then tested all the endpoints in the postman to check whether all the routes is correctly connected with the correct logics. 
#### Then we had a session with Shree Ram anna, software engineer in Surfboard payment. He took the session about Backend development. Today the session was different from the other days we have hands on practice, which was really helpful for me the understand the concept easier. Backend is the server side of an application which handles the logics, database management. Before going into the development anna explained about the OSI Model. I learned about how the data travels in the OSI layer. OSI ( Open systems Interconnection ) model decribes about how the data travels in the network. It has seven layers, and each one is responsible for its process. 
#### Physical layer, it is the core part where the data are transmitted to the server and it is binary code. Data link layer is responsible for error free transmission through air frequency means wireless medium. Network layer is responsible for creating the source address and destination address and here the data’s will be bundled. Transport layer is responsible for the reliable data delivery and uses TCP for HTTP / HTTPS. The session layer is used to control sessions like API tokens, login session and manage conversation between computers. Presentation layer is responsible for translation, encryption, and compression of data. Application layer provides services directly like browsers, etc. and it provides protocols that enables software to send and receive data. 
#### For example sender sends the Hi message  to receiver and it will be passed through the server. The physical layer transmits it to binary data. The data link layer adds MAC address of the sender and gateway and provide error free transmission. The network layers adds the source and destination IP address. The transport layer use TCP that breaks message into packets and tracks them. The session layer manages secure connection to the packets. Presentation layer done the JSON formatting and encryption, converts HI to encrypted binary. Application layer where the message Hi is typed into the app and sent via HTTP post. 
#### HTTP ( Hyper Text Transfer Protocol ), is like the language the web browser and the server use to talk the each other. HTTP is used to send and receive data, allow browser to talk to the server for something and waits for the server to respond. We have two methods HTTP request and HTTP response. HTTP version tells the server which HTTP version the browser is using like 1.1, 2. Then comes the URL , web addess trying to access. It includes http:// and domain name like google and then Top level domain like .com, .org, .gov, .in and etc. we also have port number like 3000, 4200. Headers will have the extra information send with the request. Content-Type: What type of data you're sending (like application/json), Authorization: Bearer abc123token login tokens. Body has the actual data being sent. 
#### Then learned about Bun, it is a modern JavaScript runtime like node.js but it is faster and has more built-in tools. It uses a fast language called Zig. It has built-in package manager as it is faster and simpler. It also has built-in tester, write and run tests without installing anything extra. Elysia is a framework for building backend apps using bun. We use express.js for node.js similarly Elysia for bun. We import and use it in our app like express.js
#### Then created a server using elysia. First created a simple endpoint to print some message. Then created a route GET, PUT, PATCH and DELETE on the path ‘/’ on the server that interact with the file my-file.txt.  The GET route reads and returns the contents of the file, similarly the other routes does it work. They take the incoming request, converts into a string using JSON>stringify and appens it ro the file using WriteFileSync with the flag “a”. instead of overwriting the file, each new request add the data to the end of the file. 
#### writeFileSync is used to write the data to the file. we give the file path and the content and it write the content into the file in synchronous. The readFileSync is used to read the content of a file, we pass the file path and it reads the content and returns it. Both the files are synchronous they block the program and wait until the file work is done before moving to the next line. Then learned about swagger, like postman we can test the routes in it. We can install it and import it in our app to use. It will have all the endpoints we have in our program. We can use test request to test the endpoints. 
#### Thank you.
